/////////////////////////////////////////////////////////////////////////////
//
// Written by Yaniv Golan, ygolan@hyperact.com
// http://www.hyperact.com
// Copyright (C) 1996 - 1998 by HyperAct, Inc.
// All Rights Reserved.
//
/////////////////////////////////////////////////////////////////////////////
unit HtmlTxt;

interface

{$I WapDef.INC}

{$ifdef wap_cbuilder}
    {$ObjExportAll On}
{$endif wap_cbuilder}

uses Classes, SysUtils, Graphics, AppSSI, WapActns, WVarDict
    ;


const
    NewLine = #13#10;

type

{$ifndef wap_cbuilder}
THttpRequest = AppSSI.THttpRequest;
THttpResponse = AppSSI.THttpResponse;
{$endif wap_cbuilder}

THtmlColor = TColor;

TCustomHtmlForm = class;
THtmlForm = class;
THtmlFormControl = class;
THtmlSelect = class;
THtmlText = class;
THtmlHidden = class;
THtmlTextArea = class;
THtmlRadio = class;
THtmlCheckbox = class;
THtmlButton = class;
THtmlRadioGroup = class;
THtmlCheckboxGroup = class;
THtmlChunk = class;

{:  A base abstract class for those WebApp components which correspond to
    certain HTML elements on a Web page generated by a WebApp application
    (espacially HTML controls inside a FORM ... /FORM block). The <b>TWapControl</b>
    class encapsulates the common functionality which allows a derived
    component to generate HTML for it's corresponding HTML element (see
    <see property=TWapControl.AsHtml>) and to extract changes to its value
    from the received data after the form is submitted.
@seeAlso
    <jump id=macros text="WebApp and dynamically generated contents">
}
TWapControl = class(TWapCustomAction)
private
    function GetAsHtml: string;
protected
    {: This protected method must be overriden in each derived class to
      analize the passed-in <p>Value</p> parameter and setup whatever the
      component has for its 'value' property accordingly. For the base class,
      <b>SubMitValue</b> does nothing, for a <see class=THtmlText> component
      the <i>Value</i> just get stored to its <see property=THtmlText.Text
      text = "Text"> property and so on.    
      <p><b>SubmitValue</b> is used by the <see method=TWapControl.ExecuteSubmit>
      method.}
    procedure SubmitValue(const Value: string); virtual;

    {: Supports one of two predefined actions: 'Submit' or 'WriteHtml'.
      The default action for <b>TWapControl</b>s is 'WriteHtml', although
      this might be overriden in an inherited class.
    @seeAlso  <see method=TWapControl.DoDefault><br>
        <see method=TWapControl.ExecuteWriteHtml><br>
        <see method=TWapControl.ExecuteSubmit><br>      }
    procedure Execute(
        Request: THttpRequest; Response: THttpResponse;
        const Verb, Value: string; Params: TVariantList;
        var Handled: boolean); override;

    // VERBS

    {: Invokes the default action for a <see class=TWapControl>-derived
      component. The action is 'WriteHtml', unless overriden in a particular class }
    procedure DoDefault(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList;
        var Handled: Boolean); virtual;

    {: Implements an action on submitting an HTML form containing an HTML
      representation of this WebApp component.
      Simply calls <see method=TWapControl.SubmitValue>.
      <p>This method is called in response to the Submit verb. Also,
      for <see class=THtmlFormControl>-derived components, it is the default
      action.
      @seeAlso  <see class=THtmlForm>}
    procedure ExecuteSubmit(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList;
        var Handled: Boolean); virtual;

    {: Implements an action of generating HTML text for this component.
      Since this is the default action, a name of a TWapControl-derived
      component, mentioned in a <jump id=templates text="WebApp template file">
      (like <RawData> "<H1>Enter your name : <%~EditName%></H1>" </RawData>)
      gets replaced by the correct representation of an HTML control.
      Before the HTML is generated, <b>TWapControl.ExecuteSubmit</b>
      uses the passed-in <i>Params</i> to set any exposed properties with
      matching names, thus allowing some customization of the output HTML. }
    procedure ExecuteWriteHtml(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList;
        var Handled: Boolean); virtual;

    {: This abstract method must be overriden in each derived class to specify
      the exact way the component is represented in HTML. To form the HTML
      representation, add more or more lines to the <i>Dest</i> string list
      parameter. }
    procedure ProduceHtml(Dest: TStrings); virtual; abstract;

public
    {: A standard constructor }
    constructor Create(AOwner: TComponent); override;
    {: A standard constructor }
    destructor Destroy; override;

    {: Writes HTML representation of the component to a specified string list.
      Uses the <see method=TWapControl.ProduceHTML> method to do the work. }
    procedure WriteToStrings(Strings: TStrings); virtual;

    {: Writes HTML representation of the component to a stream. Internally
      uses the <see method=TWapControl.WriteToStrings> method to prepare
      a temporary string list, then writes that to the stream. }
    procedure WriteToStream(Stream: TStream); virtual;

    {: Writes HTML representation of the component to a file. Uses
      the <see method=TWapControl.WriteToStream> method to do the work. }
    procedure WriteToFile(const Filename: string); virtual;

    {: Retrieves the HTML equivalent of this component as a string. Is based
      on the <see method=TWapControl.WriteToStrings> method.
    @seeAlso
      <see method=TWapControl.WriteToStream>,
      <see method=TWapControl.WriteToFile>}
    property AsHTML: string read GetAsHtml;
published
    {: This event is fired just before <see method=TWapControl.Execute> }
    property OnBeforeExecute;
    {: This event is fired just after <see method=TWapControl.Execute> }
    property OnAfterExecute;
end;

{: The base class for <see class=THtmlChunk> and <see class=TDBHtmlChunk>.
   Each class derived from <b>TCustomHtmlChunk</b> is basically a storage
   for a piece of HTML or plain text which can be referred from
   a <jump id=macros text="WebApp template"> and thus included into a
   dynamically generated Web page. }
TCustomHtmlChunk = class(TWapControl)
private
    FOnChange: TNotifyEvent;
    FLines: TStrings;
    FEscape: boolean;
    procedure SetLines(Value: TStrings);
protected
    {: Called internally by the control when its contents is changed.
      Causes the OnChange event to be fired }
    procedure Change; virtual;

    {: Outputs the lines of texts contained inside this
    <b>TCustomHtmlChunk</b>-derived object. Depending on the
    <see property=TCustomHtmlChunk.Escape> property, the text is either
    output as it is, or with 'escaping' of any special characters }
    procedure ProduceHtml(Dest: TStrings); override;

    {: This string list contains the 'HTML chunk' which the component
     would output to the Web page being constructed by the WebApp application.}
    property Lines: TStrings read FLines write SetLines;

    {: Specifies whether the piece of text in
       <see property=TCustomHtmlChunk.Lines> will be "escaped" before being
       output to the response buffer. By default the <b>Escape</b> flag is
       <b>True</b>, which means that any HTML tags in <see property=TCustomHtmlChunk.Lines>
       will be escaped and appear as text on the resulting page. Set Escape=False
       if you actually want to use HTML markup in the chunk  }
    property Escape: boolean read FEscape write FEscape;

    {: This event is fired every time the 'chunk' is changeed }
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
end;

{: Provides a place to keep a piece of HTML or plain text which can be
   referred from a <jump id=macros text="WebApp template"> and thus included
   into a dynamically generated Web page. See details in the description of the
   base class <see class=TCustomHtmlChunk>. See also <see class=TDBHtmlChunk>
   for a data-aware version of this component.
  @component
}
THtmlChunk = class(TCustomHtmlChunk)
published
    {: This string list contains the 'HTML chunk' which the component
     would output to the Web page being constructed by the WebApp application.}
    property Lines;
    {: Specifies whether the piece of text in <see property=THtmlChunk.Lines>
     will be "escaped" before being output.
     See also <see property=TCustomHtmlChunk.Escape> for more details. }
    property Escape;
end;

{:  This is the base class for components representing HTML input controls
    on a form. The WebApp HTML Form Controls are a WebApp Controls with
    the following additional attributes :
<ul>
    <li>They can be associated with a Form (<see class=THtmlForm>) control;
    <li>Their default verb is <strong>Submit</strong>
    <li>They have an <see event=THtmlFormControl.OnChange> event, which is
        fired whenever their value changes.
</ul>
    The following form controls are currently defined:

    <see class=THtmlSelect><br>
    <see class=THtmlText><br>
    <see class=THtmlTextArea><br>
    <see class=THtmlHidden><br>
    <see class=THTMLRadioGroup><br>
    <see class=THTMLRadio><br>
    <see class=THTMLCheckbox><br>
    <see class=THTMLButton><br>
    <see class=THTMLCheckboxGroup>
}
THtmlFormControl = class(TWapControl)
private
    FOnChange: TNotifyEvent;
    FHtmlForm: TCustomHtmlForm;
    procedure SetHtmlForm(Value: TCustomHtmlForm);
protected
    {: The default verb for form controls is Submit }
    procedure DoDefault(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList;
        var Handled: Boolean); override;

    {: Called internally by the control when its contents is changed.
      Causes the OnChange event to be fired }
    procedure Change; virtual;
    {: Fired whenever the value of the control is changed}
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
published
    {: The 'containing' form must be set before the component could
     properly receive the <see event=THtmlFormControl.OnChange> events
     @todo Details? }
    property HtmlForm: TCustomHtmlForm read FHtmlForm write SetHtmlForm;
end;

{:  The base class for <see class=THtmlSelect>. The component generates
    the HTML "SELECT" element, which a browser displays as a listbox
    to choose one or more values from. }
TCustomHtmlSelect = class(THtmlFormControl)
private
    FSize: integer;
    FItems: TStrings;
    FItemIndex: integer;
    FMultiSelect: boolean;
    procedure SetItems(Strings: TStrings);
    function FindValueIndex(const Value: string): integer;
    function GetValueAt(Index: integer): string;
    procedure OnItemsChange(Sender: TObject);
    procedure SetItemIndex(Value: integer);
protected
    procedure ProduceHtml(Dest: TStrings); override;
    procedure SubmitValue(const Value: string); override;
public
    constructor Create(AOwner: TComponent); override;
    destructor  Destroy; override;

    property Size: integer read FSize write FSize;
    property Items: TStrings read FItems write SetItems;
    property ItemIndex: integer read FItemIndex write SetItemIndex;
    property MultiSelect: boolean read FMultiSelect write FMultiSelect;
end;

{:  The component generates the "SELECT" HTML control,
    which a browser displays as a listbox to choose one or more values from.
    @component }
THtmlSelect= class(TCustomHtmlSelect)
public
    constructor Create(AOwner: TComponent); override;
published
    {: Determines the height of the listbox on the HTML form, in lines.
    If non-zero, this property includes the "SIZE=" parameter into the
    HTML output. For example, if <see property=THtmlSelect.Items> contains
    200 items and <b>Size</b> = 8, then only 8 items will be visible in the
    list box, with the scrollbar to see the others. }
    property Size;

    {: This string list determines the contents of the selection listbox.
      The actual height of the box is controlled by <see property=THtmlSelect.Size>}
    property Items;

    {: Represents the index of the currently selected item  }
    property ItemIndex;

    {: The value of True includes the "MULTIPLE" parameter into the
    SELECT tag generated by this component, which means that the user
    will be able to select more than one item in the list.
    @todo  Selecting multiple items is not currently supported!!! }
    property MultiSelect;

    {: This event is fired whenever the <see property=THtmlSelect.Items Text=Items>
     property is changed
    @todo ? Verify description }
    property OnChange;
end;

{:  The base class for <see class=THtmlText>. The component generates
    the HTML "INPUT TYPE=Text" element, which a browser displays as a
    single-line text edit box. See <see class=THtmlText> for details. }
TCustomHtmlText = class(THtmlFormControl)
private
    FSize: integer;
    FPassword: boolean;
    FText: string;
    FMaxLength: integer;
    procedure SetText(const Value: string);
protected
    procedure ProduceHtml(Dest: TStrings); override;
    procedure SubmitValue(const Value: string); override;
    property MaxLength: integer read FMaxLength write FMaxLength;
    property Size: integer read FSize write FSize;
    property Password: boolean read FPassword write FPassword;
public
    property Text: string read FText write SetText;
end;

{:  This component generates the "INPUT TYPE=Text" HTML control,
    which a browser displays as a single-line text edit box.
  @component    }
THtmlText = class(TCustomHtmlText)
public
    constructor Create(AOwner: TComponent); override;
published
    {: The value of the text box. This property works both ways: when
     the "WriteHTML" verb is called on the component to produce its HTML
     representation, the value of <b>Text</b> specifies the initial text
     appearing in the text input field; when the form is submitted, the
     text entered by the user ends up in the <b>Text</b> property of this
     WebApp component. }
    property Text;

    {: Specifies the maximum allowed length for <see property=THtmlText.Text>.
     Non-zero <b>MaxLength</b> causes "MAXLENGTH=..." parameter to be generated.
     Don't confuse this with <see property=THtmlText.Size>, which determines
     the visible size of the input field. }
    property MaxLength;

    {: Specifies the visible size of the input field, in characters.
     Non-zero <b>Size</b> causes "SIZE=..." parameter to be generated.
     Don't confuse this with <see property=THtmlText.MaxLength>, which sets
     the limit on the maximum length of the string which can be entered into
     this field. }
    property Size;

    {: Indicates if the text input field is used as a password entry field.
      If this property is <b>True</b>, the "INPUT TYPE=PASSWORD" tag is
      generated instead of "INPUT TYPE=TEXT". }
    property Password;

    {: This event is fired whenever the <see property=THtmlText.Text>
     property changes. In particular, this happens as the result of submitting
     the HTML form with the text input field modified by the user. }
    property OnChange;
end;

{:  The base class for <see class=THtmlTextArea>. The component generates
    the "TEXTAREA" HTML control, which a browser displays as a
    multi-line text edit box. See <see class=THtmlTextArea> for details. }
TCustomHtmlTextArea = class(THtmlFormControl)
private
    FRows: integer;
    FCols: integer;
    FLines: TStrings;
    FMaxLength: integer;
    procedure SetLines(Value: TStrings);
    procedure HandleLinesChange(Sender: TObject);
protected
    procedure ProduceHtml(Dest: TStrings); override;
    procedure SubmitValue(const Value: string); override;
public
    constructor Create(AOwner: TComponent); override;
    destructor  Destroy; override;
    property MaxLength: integer read FMaxLength write FMaxLength;
    property Rows: integer read FRows write FRows;
    property Cols: integer read FCols write FCols;
public
    property Lines: TStrings read FLines write SetLines;
end;

{:  The component generates the HTML "TEXTAREA" element,
    which a browser displays as a multi-line text edit box.
   @component    }
THtmlTextArea = class(TCustomHtmlTextArea)
public
    constructor Create(AOwner: TComponent); override;
published
    {: Specifies the maximum allowed length for the text in <see property=THtmlTextArea.Lines>.
     Non-zero <b>MaxLength</b> causes "MAXLENGTH=..." parameter to be generated.
     See also <see property=THtmlTextArea.Rows> and <see property=THtmlTextArea.Cols>,
     which determine the visible dimensions of the text input area. }
    property MaxLength;

    {: Determines the visible height (in lines) of the text input area.
    If non-zero, causes the "ROWS=..." parameter of the TEXTAREA tag to be
    generated. See also <see property=THtmlTextArea.Cols>  }
    property Rows;
    {: Determines the visible width (in characters) of the text input area.
    If non-zero, causes the "COLS=..." parameter of the TEXTAREA tag to be
    generated. See also <see property=THtmlTextArea.Rows>  }
    property Cols;

    {: The multiline text value of the component. This property works both ways:
     when the "WriteHTML" verb is called on the component to produce its HTML
     representation, the value of <b>Lines</b> specifies the initial text
     appearing in the text input field; when the form is submitted, the
     text entered by the user ends up in the <b>Lines</b> property of this
     WebApp component. }
    property Lines;

    {: This event is fired whenever the <see property=THtmlTextArea.Liness>
     property changes. In particular, this happens as the result of submitting
     the HTML form with the text area input field modified by the user. }
    property OnChange;
end;

{:  The base class for <see class=THtmlHidden>. The component generates
    the "INPUT TYPE=Hidden" HTML control. A hidden form field is not visible
    on the HTML page, but can be used as a kind of "variable" to store some text
    and then send it back to the server when the form is submitted.
    See <see class=THtmlHidden> for details. }
TCustomHtmlHidden = class(THtmlFormControl)
private
    FValue: string;
protected
    procedure ProduceHtml(Dest: TStrings); override;
    procedure SetValue(const Value: string);
    procedure SubmitValue(const Value: string); override;
public
    property Value: string read FValue write SetValue;
end;

{:  The component corresponds to the "INPUT TYPE=Hidden" HTML control.
    A hidden form field is not visible on the HTML page,
    but can be used as a kind of "variable" to store some text
    and then send it back to the server when the form is submitted.
   @component    }
THtmlHidden = class(TCustomHtmlHidden)
public
    constructor Create(AOwner: TComponent); override;
published
    {: The string value to be stored in the "hidden" form field.
     When the "WriteHTML" verb is called on the component to produce its HTML
     representation, the <b>Value</b> is sent to the client browser; when
     the form is submitted, that string ends up back in the <b>Value</b>
     property of this WebApp component. }
    property Value;
    {: This event is fired whenever the <see property=THtmlHidden.Value>
     property changes. In particular, this happens as the result of receiving
     the value with the submitted HTML form. }
    property OnChange;
end;

{:  The base class for <see class=THtmlRadio>. The component generates
    the "INPUT TYPE=Radio" HTML control, which a browser displays as a
    single "radio button".  See <see class=THtmlHtmlRadio> for details. }
TCustomHtmlRadio = class(THtmlFormControl)
private
    FChecked: boolean;
    FValue: string;
    FCaption: string;
    procedure SetChecked(Value: boolean);
protected
    procedure ProduceHtml(Dest: TStrings); override;
    procedure SubmitValue(const Value: string); override;
    property Checked: boolean read FChecked write SetChecked;
    property Value: string read FValue write FValue;
    property Caption: string read FCaption write FCaption;
public
    constructor Create(AOwner: TComponent); override;
end;

{: This component generates the "INPUT TYPE=Radio" HTML control,
   which a browser displays as a single "radio button".
   Since radio buttons are used in groups, it is usually more
   convenient to represent the whole group by a single
   <see class=THtmlRadioGroup> WebApp component.
 @component
}
THtmlRadio = class(TCustomHtmlRadio)
public
    constructor Create(AOwner: TComponent); override;
published
    {: Indicates that the radio button is checked. This is the "value"
     of the component. When the "WriteHTML" verb is called, <b>Checked</b>
     controls the "CHECKED" HTML parameter; when the form is submitted,
     the changes made by the customer are reflected in the <b>Checked</b> property}
    property Checked;

    {: A string which is passed back to the server when the radio button
    is checked. By default the string is "ON" and you normally don't need
    to change it. The name of this property is a bit confusing: note that
    the property which receives user input is not <b>Value</b>, but
    <see property=THtmlRadio.Checked text=Checked>}
    property Value;

    {: This event is fired whenever the <see property=THtmlRadio.Checked>
     property changes. In particular, this happens as the result of receiving
     the value with the submitted HTML form. }
    property OnChange;

    {: @todo}
    property Caption;
end;

{:  The base class for <see class=THtmlCheckbox>. The component generates
    the "INPUT TYPE=CHECKBOX" HTML control, which a browser displays as a
    single check box.  See <see class=THtmlCheckbox> for details. }
TCustomHtmlCheckbox = class(THtmlFormControl)
private
    FChecked: boolean;
    FValue: string;
    FCaption: string;
    procedure SetChecked(Value: boolean);
protected
    procedure ProduceHtml(Dest: TStrings); override;
    procedure SubmitValue(const Value: string); override;
    property Checked: boolean read FChecked write SetChecked;
    property Value: string read FValue write FValue;
    property Caption: string read FCaption write FCaption;
public
    constructor Create(AOwner: TComponent); override;
end;

{: This component generates the the "INPUT TYPE=CHECKBOX" HTML control,
   which a browser displays as a single check box.
   If you need several check boxes, it might be more convenient to represent
   them by a single <see class=THtmlCheckBoxGroup> WebApp component.
 @component
}
THtmlCheckbox = class(TCustomHtmlCheckbox)
public
    constructor Create(AOwner: TComponent); override;
published
    {: Indicates that the checkbox is checked. This is the "value"
     of the component. When the "WriteHTML" verb is called, <b>Checked</b>
     controls the "CHECKED" HTML parameter; when the form is submitted,
     the changes made by the customer are reflected in the <b>Checked</b> property}
    property Checked;

    {: A string which is passed back to the server when the checkbox
    is checked. By default the string is "ON" and you normally don't need
    to change it. The name of this property is a bit confusing: note that
    the property which receives user input is not <b>Value</b>, but
    <see property=THtmlCheckbox.Checked> text=Checked}
    property Value;

    {: This event is fired whenever the <see property=THtmlCheckBox.Checked>
     property changes. In particular, this happens as the result of receiving
     the check state with the submitted HTML form. }
    property OnChange;

    {: @todo}
    property Caption;
end;

{: This enumeration specifies the button type:
<ul>
    <li>btNormal  - a button without any default action
    <li>btSubmit  - submits the form
    <li>btReset   - resets all form fields to their initial values
</ul>
}
THtmlButtonType = (btNormal, btSubmit, btReset);


{:  The base class for <see class=THtmlButton>. The component generates
    the one of the "INPUT TYPE=SUBMIT|RESET|BUTTON" HTML buttons.
    See <see class=THtmlButton> for details. }
TCustomHtmlButton = class(THtmlFormControl)
private
    FButtonType: THtmlButtonType;
    FValue: string;
    procedure SetValue(const Value: string);
protected
    procedure ProduceHtml(Dest: TStrings); override;
    procedure SubmitValue(const Value: string); override;
    property Value: string read FValue write SetValue;
    property ButtonType: THtmlButtonType read FButtonType write FButtonType;
    // synonim for the value property
    property Caption: string read FValue write SetValue;
public
    constructor Create(AOwner: TComponent); override;
end;

{:  The component generates one of the "INPUT TYPE=SUBMIT|RESET|BUTTON"
  HTML buttons. Unlike other HTML "input" controls, the buttons don't
  supply any information to the WebApp when the form is submitted.
  For this reason, the <see method=TCustomHtmlButton.SubmitValue text=SubmitValue>
  method for this component is empty.
 @component
}
THtmlButton = class(TCustomHtmlButton)
public
    constructor Create(AOwner: TComponent); override;
published
    {: Defines the caption of the button (the text a browser displays on
    the button. Maps to the "VALUE=..." parameter of the INPUT tag }
    property Value;

    {: Specifies the action of the button. Currently only btSubmit and
    btReset should be used.
    @todo
      With the type of btNormal, a button won't do
      anything, since the component currently does not provide a way
      to associate a client-side script with the button    }
    property ButtonType;
    {: This event is fired whenever the <see property=THtmlButton.Value>
     property (the caption of the button) changes. In particular, this happens
     as the result of receiving the check state with the submitted HTML form. }
    {: @todo}
    property Caption;

    property OnChange;
end;

{:  The base class for <see class=THtmlRadioGroup>. The component generates
    a set of "INPUT TYPE=RADIO" HTML controls, one for each item in the
    <see property=THtmlRadioGroup.Items text=Items> property.
    See <see class=THtmlRadioGroup> for details. }
TCustomHtmlRadioGroup = class(THtmlFormControl)
private
    FItems: TStrings;
    FItemIndex: integer;
    FBetweenItems: string;
    procedure SetItems(Value: TStrings);
    function FindValueIndex(const Value: string): integer;
    function GetValueAt(Index: integer): string;
    procedure SetItemIndex(Value: integer);
    procedure OnItemsChange(Sender: TObject);
protected
    procedure ProduceHtml(Dest: TStrings); override;
    procedure SubmitValue(const Value: string); override;
    property BetweenItems: string read FBetweenItems write FBetweenItems;
    property Items: TStrings read FItems write SetItems;
    property ItemIndex: integer read FItemIndex write SetItemIndex;
public
    constructor Create(AOwner: TComponent); override;
    destructor  Destroy; override;
end;

{:  The component generates a set of "INPUT TYPE=RADIO" HTML controls,
    one for each item in the <see property=THtmlRadioGroup.Items text=Items> property.
    The component can be used to represent a set of mutually-exclusive
    options on the HTML form.
 @component
}
THtmlRadioGroup = class(TCustomHtmlRadioGroup)
public
    constructor Create(AOwner: TComponent); override;
published
    {: A portion of HTML markup which should be used to separate items
    in the radio group. By default, the "BR" tag is used. }
    property BetweenItems;
    {: Represents the index (in <see property=THtmlRadioGroup.Items text=Items>)
    of the currently choosen radio button.  This is the "value" property of the
    component, which receives a new value when the HTML form is submitted. }
    property ItemIndex;
    {: The list of radio button names. Each line in <b>Items</b> causes a single
     "radio" HTML control to be generated. }
    property Items;
    {: This event is fired whenever the <see property=THtmlRadioGroup.Items>
     property changes.
    @todo ? Verify that this is the expected behaviour }
    property OnChange;
end;

{:  The base class for <see class=THtmlCheckBoxGroup>. The component generates
    a set of "INPUT TYPE=CHECKBOX" HTML controls, one for each item in the
    <see property=THtmlCheckBoxGroup.Items text=Items> property.
    See <see class=THtmlCheckBoxGroup> for details. }
TCustomHtmlCheckboxGroup = class(THtmlFormControl)
private
    FItems: TStrings;
    FBetweenItems: string;
    function GetSelected(Index: integer): boolean;
    procedure SetSelected(Index: integer; Value: boolean);
    procedure SetItems(Value: TStrings);
    function GetValueAt(Index: integer): string;
protected
    procedure ProduceHtml(Dest: TStrings); override;
    procedure SubmitValue(const Value: string); override;
public
    constructor Create(AOwner: TComponent); override;
    destructor  Destroy; override;

    {: The array of checked/not-checked flags for each element of <b>Items</b>.
    This property specifies the initial states of the check boxes when the HTML
    controls are generated, and it receives any changes made by the user
    when the form is submitted }
    property Selected[Index: integer]: boolean read GetSelected write SetSelected;

    property BetweenItems: string read FBetweenItems write FBetweenItems;
    property Items: TStrings read FItems write SetItems;
end;

{:  The component generates a set of "INPUT TYPE=CHECKBOX" HTML controls,
    one for each item in the <see property=THtmlCheckBoxGroup.Items text=Items>
    property.
    The component can be used to represent a set of options which can be
    checked or unchecked independently from each other.
 @component
}
THtmlCheckboxGroup = class(TCustomHtmlCheckboxGroup)
public
    constructor Create(AOwner: TComponent); override;
published
    {: A portion of HTML markup which should be used to separate the
    checkboxes from each other. By default, the "BR" tag is used. }
    property BetweenItems;
    {: The list of checkbox names. Each line in <b>Items</b> causes a single
     "CHECKBOX" HTML control to be generated. The selection state of each
     item is stored in the <see property=TCustomHtmlCheckboxGroup.Items text=Items>
     property array.  }
    property Items;
    {: This event is fired whenever the <see property=THtmlCheckBoxGroup.Items>
     property changes.
    @todo ? Verify that this is the expected behaviour }
    property OnChange;
end;

// UNDER CONSTRUCTIONS, DO NOT USE!

THtmlFormBeforeSubmitEvent = procedure(
    Sender: TObject;
    Request: THttpRequest; Response: THttpResponse;
    const Value: string; Params: TVariantList) of object;

THtmlFormAfterSubmitEvent = procedure(
    Sender: TObject;
    Request: THttpRequest; Response: THttpResponse;
    const Value: string; Params: TVariantList) of object;

{:  This is the base class for <see class=THtmlForm>, the component which
    represents an HTML form in a WebApp application.
    See <see class=THtmlForm> for more details. }

TCustomHtmlForm = class(TWapCustomAction)
private
    FControls: TList;
    FOnBeforeSubmit: THtmlFormBeforeSubmitEvent;
    FOnAfterSubmit: THtmlFormAfterSubmitEvent;
    procedure AddControl(Control: THtmlFormControl);
    procedure RemoveControl(Control: THtmlFormControl);
    function GetControlCount: integer;
    function GetControl(Index: integer): THtmlFormControl;
protected
    {: Processes several form-specific verbs: 'WriteFormBegin', 'WriteFormEnd'
    and 'WriteControlHtml') to generate the HTML code for the form
    (see
      <see method=TCustomHtmlForm.ExecuteWriteFormBegin text=ExecuteWriteFormBegin>,
      <see method=TCustomHtmlForm.ExecuteWriteFormEnd text=ExecuteWriteFormEnd>
      and <see method=TCustomHtmlForm.ExecuteWriteControlHtml text=ExecuteWriteControlHtml>,
      respectively) and the 'Submit' verb to process the submitted form
      (see <see method=TCustomHtmlForm.ExecuteSubmit text=ExecuteSubmit>)  }
    procedure Execute(
        Request: THttpRequest; Response: THttpResponse;
        const Verb, Value: string; Params: TVariantList;
        var Handled: boolean); override;
    {: Fires the <see event=THtmlForm.OnBeforeSubmit> event }
    procedure BeforeSubmit(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList);

    {: Fires the <see event=THtmlForm.OnAfterSubmit> event }
    procedure AfterSubmit(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList);
    // VERBS

    {: Writes to the response buffer the FORM tag,
    with all the required parameters, and some other tags which guarantees
    that the THtmlForm's Submit action will be called when the form is submitted. }
    procedure ExecuteWriteFormBegin(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList;
        var Handled: boolean); virtual;

    {: Takes the mandatory 'Control' parameter from <i>Params</i>, looks for
       that control in the <see property=TCustomHtmlForm.Controls text=Controls>
       list and, if found, calls its 'WriteHtml' action. }
    procedure ExecuteWriteControlHtml(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList;
        var Handled: boolean); virtual;

    {: Writes the /FORM end-tag into the response buffer }
    procedure ExecuteWriteFormEnd(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList;
        var Handled: boolean); virtual;

    {: Called when the HTML form is submitted. This method calls 'Submit'
    on each of the <see property=TCustomHtmlForm.Controls text=Controls>,
    passing to them values entered by the user to their respective HTML
    controls }
    procedure ExecuteSubmit(
        Request: THttpRequest; Response: THttpResponse;
        const Value: string; Params: TVariantList;
        var Handled: boolean); virtual;

    property OnBeforeSubmit: THtmlFormBeforeSubmitEvent read FOnBeforeSubmit write FOnBeforeSubmit;
    property OnAfterSubmit: THtmlFormAfterSubmitEvent read FOnAfterSubmit write FOnAfterSubmit;
public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    {: Returns the number of controls in the
    <see property=TCustomHtmlForm.Controls text=Controls> list. }
    property ControlCount: integer read GetControlCount;

    {: Contains the list of WebApp HTML Form Controls associated with
    with this HTML form. A form control get on this list when you assign
    its <see property=THtmlFormControl.HtmlForm> property }
    property Controls[Index: integer]: THtmlFormControl read GetControl;

    {: Finds a form control by its name. The search is case-insensitive.
     If no matching control is found, the function returns NIL.  }
    function ControlByName(const Name: string): THtmlFormControl;
end;

{:  This component represents an HTML form in a WebApp application.
    <b>THtmlForm</b> maintains a list of WebApp
    <see class=THtmlFormControl text="form controls"> on
    this form in the <see property=TCustomHtmlForm.Controls text=Controls> property
    and supports several "verbs" to generate HTML code for the form
    ( 'WriteFormBegin', 'WriteFormEnd' and 'WriteControlHtml') and to
    process the submitted form ('Submit')
 @component
}
THtmlForm = class(TCustomHtmlForm)
published
    {: The event is fired just before the default Submit processing
     @todo Some example of how it is supposed to be used? }
    property OnBeforeSubmit;
    {: The event is fired just after the default Submit processing
     @todo Some example of how it is supposed to be used? }
    property OnAfterSubmit;
end;

{:  This is the base class for <b>THtmlJavaApplet</b>.
    See <see class=THtmlJavaApplet> for more details. }
TCustomHtmlJavaApplet = class(TWapControl)
private
    FArchive: string;
    FCodeBase: string;
    FCode: string;
    FWidth: integer;
    FHeight: integer;
    FHSpace: integer;
    FVSpace: integer;
    FAlign: string;
    FParams: TStrings;
    procedure SetParams(Value: TStrings);
protected
    procedure ProduceHtml(Dest: TStrings); override;

    property Archive: string read FArchive write FArchive;
    property CodeBase: string read FCodeBase write FCodeBase;
    property Code: string read FCode write FCode;
    property Width: integer read FWidth write FWidth;
    property Height: integer read FHeight write FHeight;
    property HSpace: integer read FHSpace write FHSpace;
    property VSpace: integer read FVSpace write FVSpace;
    property Align: string read FAlign write FAlign;
    property Params: TStrings read FParams write SetParams;
public
    constructor Create(AOwner: TComponent); override;
    destructor  Destroy; override;
end;

{:  This component can be used to include a Java applet into
    a Web generated by the WebApp application. The name of a
    <b>THtmlJavaApplet</b> component, referred from a
    <jump id=macros text="WebApp template">, will be replaced
    by the APPLET tag, with parameters controlled by the properties
    of the component. }
THtmlJavaApplet = class(TCustomHtmlJavaApplet)
published
    {: This attribute specifies one or more comma-separated names of
      the archives containing classes and other resources that will be "preloaded".
      The classes are loaded using an instance of an AppletClassLoader with the
      given codebase. Preloading resources can significantly improve the
      performance of applets }
    property Archive;
    {: This attribute specifies the base URL for the applet.
      If this attribute is not specified, then the base URL for the applet is
      the same as for the current document. }
    property CodeBase;
    {: This attribute specifies the name of the resource that contains
      the applet's compiled applet subclass. The value must be a relative URL
      with respect to the applet base URL }
    property Code;
    {: Specifies the initial width of the applet display area
    (not counting any windows or dialogs that the applet brings up) }
    property Width;
    {: Specifies the initial height of the applet display area
    (not counting any windows or dialogs that the applet brings up). }
    property Height;
    {: Suggested horizontal gutter, in pixels }
    property HSpace;
    {: Suggested vertical gutter, in pixels }
    property VSpace;

    { This attribute specifies the position of the object with respect
    to its surrounding context. The values recognized by browsers are
    "bottom", "middle", "top","left" and "right". }
    property Align;

    {: The list of parameters to be passed to the applet. Each string
    in the list is usually in the "name=value" format (if '=' is not there,
    the whole string is assumed to be the parameter name and the value is empty).
    Each items in <b>Params</b> generates a <code><RawData>
      <PARAM NAME="name" VALUE="value"></RawData></code> tag during the
    'WriteHTML' action }
    property Params;
end;

{ Each of the following functions returns a string with a piece of
  HTML text. These functions can be used as convenient shortcuts when
  generating HTML text }


{: Returns <code><RawData>
  "<Tag>"
  </RawData></code> }
function Tag(const Tag: string): string;

{: Returns <code><RawData>
  "<Tag Attributes>"
  </RawData></code> }
function TagWithAttributes(const Tag: string; const Attributes: array of string): string;

{: Returns the end tag: <code><RawData>
  "</Tag>"
  </RawData></code> }
function EndTag(const Tag: string): string;

{: Encloses <i>Text</i> with the specified tag and its end-tag
  <code><RawData>
  "<Tag>...</Tag>"
  </RawData></code> }
function EnclosingTag(const Tag, Text: string): string;

{: Combines <see routine=TagWithAttributes> with <see routine=EnclosingTag>:
  <code><RawData>
  "<Tag Attributes> .. Text ..</Tag>"
  </RawData></code> }
function EnclosingTagWithAttributes(
    const Tag: string;
    const Attributes: array of string;
    Text: string
    ): string;

{: Returns a named attribute:
  <code><RawData>
  'Name="Value"'
  </RawData></code> }
function Attribute(const Name, Value: string): string;

// <Html [attributes]>....</Html>
function Html(const Text: string): string;

// <HEAD [attributes]>....</HEAD>
function Head(const Text: string): string;

// <BODY>....</BODY>
function Body(const Text: string): string;

// <BODY Attributes>.. Text ..</BODY>
function BodyWithAttributes(const Attributes: array of string; const Text: string): string;

// <I>....</I>
function Italic(const Text: string): string;

// <B>....</B>
function Bold(const Text: string): string;

// <U>....</U>
function Underline(const Text: string): string;

// <SCRIPT LANGUAGE="ScriptLanguage">
// <!--
// .. text ..
// // -->
// </script>

function Script(const ScriptLanguage, Text: string): string;

// <NOSCRIPT>
// .. text ..
// </NOSCRIPT>

function NoScript(const Text: string): string;

// <P>
// .. text ..
// </P>
function Par(const Text: string): string;

// <P Attributes>
// .. text ..
// </P>
function ParWithAttributes(const Attributes: array of string; const Text: string): string;

// <A HREF="HRef" [TARGET="Target"]> .. text .. </A>
function Link(const HRef, Target, Text: string): string;

// <BR>
function LineBreak: string;

// <TITLE>Text</TITLE>
function Title(const Title: string): string;

// <Hn> .. text .. </Hn>
function Heading(Level: integer; const Text: string): string;

// <FORM [NAME=...] [METHOD=...] [ACTION=...] [ENCTYPE=...] [TARGET=...]>
function FormBegin(const Name, Method, Action, EncType, Target: string): string;

// </FORM>
function FormEnd: string;

// <FORM [NAME=...] [METHOD=...] [ACTION=...] [ENCTYPE=...] [TARGET=...]>
// ... text ...
// </FORM>
function Form(const Name, Method, Action, EncType, Target: string; const Text: string): string;

function ColorToHtmlColor(Color: THtmlColor): string;

function ColorToJSColor(Color: TColor): string;

// <PARAM NAME="name1" VALUE="value1"><PARAM NAME="name2" VALUE="value2">
procedure FormatStringsAsParams(SourceStrings: TStrings; DestParams: TStrings);

// <Request.ScriptName>[LogicalPath][?QueryString]
function SelfURL(Request: THttpRequest; const LogicalPath: string; const QueryString: string): string;

// Field1&Field2&Field3
function URLFields(const Fields: array of string): string;

// Field=URLEncode(Value)
function URLField(const Field, Value: string): string;

// ActionName[.Verb][=Value]
function Action(const ActionName, Verb, Value: string): string;

// ActionName[.Verb][=Value]&ActionName@Param1&ActionName&Param2...
function ActionWithParams(const ActionName, Verb, Value: string; const Params: array of string): string;

// Param[=URLEncode(Value)]
function ActionParam(const Param, Value: string): string;

implementation

uses InetStr, XStrings;

function ExtractTag(const TagWithAttributes: string): string;
var
    p: integer;
begin
    p := pos(' ', TagWithAttributes);
    if (p = 0) then
        result := TagWithAttributes
    else
        result := Copy(TagWithAttributes, 1, p - 1);
end;

function FormatAttributes(const Attributes: array of string): string;
var
    i: integer;
begin
    result := '';
    for i := Low(Attributes) to High(Attributes) do
        result := result + ' ' + Attributes[i];
end;        

// <TAG>
function Tag(const Tag: string): string;
begin
    result := '<' + Tag + '>';
end;

// <Tag Attributes>
function TagWithAttributes(const Tag: string; const Attributes: array of string): string;
begin
    result := '<' + Tag + FormatAttributes(Attributes) + '>';
end;

// </Tag>
function EndTag(const Tag: string): string;
begin
    result := '</' + Tag + '>';
end;

// <Tag> .. Text ..</Tag>
function EnclosingTag(const Tag, Text: string): string;
var
    EndTag: string;
begin
    EndTag := ExtractTag(Tag);
    result := '<' + Tag + '>' + Text + '</' + EndTag + '>';
end;

// <Tag Attributes> .. Text ..</Tag>
function EnclosingTagWithAttributes(
    const Tag: string;
    const Attributes: array of string;
    Text: string
    ): string;
begin
    result := EnclosingTag(Tag + FormatAttributes(Attributes), Text);
end;

function Attribute(const Name, Value: string): string;
begin
    result := Name + '="' + Value + '"';
end;

// <Html>....</Html>
function Html(const Text: string): string;
begin
    result := EnclosingTag('Html', NewLine + Text + NewLine);
end;

// <HEAD [attributes]>....</HEAD>
function Head(const Text: string): string;
begin
    result := EnclosingTag('HEAD', NewLine + Text + NewLine);
end;

// <BODY>....</BODY>
function Body(const Text: string): string;
begin
    result := EnclosingTag('BODY', NewLine + Text + NewLine);
end;

// <BODY Attributes>.. Text ..</BODY>
function BodyWithAttributes(const Attributes: array of string; const Text: string): string;
begin
    result := EnclosingTagWithAttributes('BODY', Attributes, NewLine + Text + NewLine);
end;

function FormBegin(const Name, Method, Action, EncType, Target: string): string;
begin
    result := '<FORM';
    if (Name <> '') then
        result := result + ' NAME="' + Name + '"';
    if (Method <> '') then
        result := result + ' METHOD="' + Method + '"';
    if (Action <> '') then
        result := result + ' ACTION="' + Action + '"';
    if (EncType <> '') then
        result := result + ' ENCTYPE="' + EncType + '"';
    if (Target <> '') then
        result := result + ' TARGET="' + Target + '"';
    result := result + '>';
end;

function FormEnd: string;
begin
    result := '</FORM>';
end;

function Form(const Name, Method, Action, EncType, Target: string; const Text: string): string;
begin
    result := FormBegin(Name, Method, Action, EncType, Target) + NewLine + Text + NewLine + FormEnd;
end;

// <I>....</I>
function Italic(const Text: string): string;
begin
    result := EnclosingTag('I', Text);
end;

// <B>....</B>
function Bold(const Text: string): string;
begin
    result := EnclosingTag('B', Text);
end;

// <U>....</U>
function Underline(const Text: string): string;
begin
    result := EnclosingTag('U', Text);
end;

// <SCRIPT LANGUAGE="ScriptLanguage">
// <!--
// .. text ..
// // -->
// </script>
function Script(const ScriptLanguage, Text: string): string;
begin
    result := EnclosingTagWithAttributes(
        'SCRIPT',
        [Attribute('LANGUAGE', ScriptLanguage)],
        '<!--' + NewLine +
        Text + NewLine +
        '// -->' + NewLine);
end;

// <NOSCRIPT>
// .. text ..
// </NOSCRIPT>
function NoScript(const Text: string): string;
begin
    result := EnclosingTag('NOSCRIPT', NewLine + Text + NewLine);
end;

// <P>
// .. text ..
// </P>
function Par(const Text: string): string;
begin
    result := EnclosingTag('P', NewLine + Text + NewLine);
end;

// <P Attributes>
// .. text ..
// </P>
function ParWithAttributes(const Attributes: array of string; const Text: string): string;
begin
    result := EnclosingTagWithAttributes('P', Attributes, NewLine + Text + NewLine);
end;

// <A HREF="HRef" [TARGET="Target"]> .. text .. </A>
function Link(const HRef, Target, Text: string): string;
begin
    if (Target = '') then
        result := EnclosingTagWithAttributes('A', [Attribute('HREF', HRef)], Text)
    else
        result := EnclosingTagWithAttributes('A', [Attribute('HREF', HRef), Attribute('TARGET', Target)], Text);
end;

// <BR>
function LineBreak: string;
begin
    result := Tag('BR');
end;

// <TITLE>Text</TITLE>
function Title(const Title: string): string;
begin
    result := EnclosingTag('TITLE', Title);
end;

// <Hn> .. text .. </Hn>
function Heading(Level: integer; const Text: string): string;
begin
    result := EnclosingTag('H' + IntTOStr(Level), Text);
end;    

constructor TWapControl.Create(AOwner: TComponent);
begin
    inherited;
end;

destructor TWapControl.Destroy;
begin
    inherited Destroy;
end;

procedure TWapControl.Execute(
    Request: THttpRequest;
    Response: THttpResponse;
    const Verb, Value: string; Params: TVariantList;
    var Handled: Boolean);
begin
    if (Verb = '') then
        DoDefault(Request, Response, Value, Params, Handled)
    else if (CompareText(Verb, 'Submit') = 0) then
        ExecuteSubmit(Request, Response, Value, Params, Handled)
    else if (CompareText(Verb, 'WriteHtml') = 0) then
        ExecuteWriteHtml(Request, Response, Value, Params, Handled)
    else
        UnsupportedVerbError(Verb);
end;

procedure TWapControl.DoDefault(
    Request: THttpRequest;
    Response: THttpResponse;
    const Value: string; Params: TVariantList;
    var Handled: Boolean);
begin
    ExecuteWriteHtml(Request, Response, Value, Params, Handled);
end;

procedure TWapControl.ExecuteSubmit(
    Request: THttpRequest;
    Response: THttpResponse;
    const Value: string; Params: TVariantList;
    var Handled: Boolean);
begin
    SubmitValue(Value);
end;

procedure TWapControl.ExecuteWriteHtml(
    Request: THttpRequest;
    Response: THttpResponse;
    const Value: string; Params: TVariantList;
    var Handled: Boolean);
begin
    UpdateProperties(Params);
    WriteToStream(Response.OutputStream);
end;

procedure TWapControl.SubmitValue(const Value: string);
begin
    // do nothing
end;

procedure TWapControl.WriteToStrings(Strings: TStrings);
begin
    Strings.BeginUpdate;
    try
        ProduceHtml(Strings);
    finally
        Strings.EndUpdate;
    end;
end;

procedure   TWapControl.WriteToStream(Stream: TStream);
var
    Strings: TStringList;
begin
    Strings := TStringList.Create;
    try
        WriteToStrings(Strings);
        Strings.SaveToStream(Stream);
    finally
        Strings.Free;
    end;
end;

procedure   TWapControl.WriteToFile(const Filename: string);
var
    FileStream: TFileStream;
begin
    FileStream := TFileStream.Create(Filename, fmCreate or fmOpenWrite or  fmShareDenyWrite);
    try
        WriteToStream(FileStream);
    finally
        FileStream.Free;
    end;
end;

function    TWapControl.GetAsHtml: string;
var
    Strings: TStringList;
begin
    Strings := TStringList.Create;
    try
        WriteToStrings(Strings);
        result := Strings.Text;
    finally
        Strings.Free;
    end;
end;

constructor TCustomHtmlSelect.Create(AOwner: TComponent);
begin
    inherited Create(AOwner);
    FItems := TStringList.Create;
    TStringList(FItems).OnChange := OnItemsChange;
    FSize := 1;
    FItemIndex := -1;
    FMultiSelect := false;
end;

destructor  TCustomHtmlSelect.Destroy;
begin
    FItems.Free;
    inherited destroy;
end;

procedure   TCustomHtmlSelect.SetItems(Strings: TStrings);
begin
    FItems.Assign(Strings);
    Change;
end;

procedure TCustomHtmlSelect.OnItemsChange(Sender: TObject);
begin
    Change;
end;

procedure TCustomHtmlSelect.SetItemIndex(Value: integer);
begin
    if (FItemIndex <> Value) then begin
        FItemIndex := Value;
        Change;
    end;
end;

function TCustomHtmlSelect.GetValueAt(Index: integer): string;
begin
    if (Pos('=', FItems[Index]) > 0) then
        result := FItems.Names[Index]
    else
        result := FItems[Index];
end;

function TCustomHtmlSelect.FindValueIndex(const Value: string): integer;
begin
    for result := 0 to (FItems.Count - 1) do begin
        if (Trim(GetValueAt(result)) = Trim(Value)) then
            exit;
    end;
    result := -1;
end;

procedure TCustomHtmlSelect.SubmitValue(const Value: string);
begin
    ItemIndex := FindValueIndex(Value);
end;

procedure TCustomHtmlSelect.ProduceHtml(Dest: TStrings);
var
    i: integer;
    s: string;
begin
    with Dest do begin
        s := '<SELECT NAME="' + Name + '"';
        if (FSize > 0) then
            s := s + ' SIZE="' + IntToStr(FSize) + '"';
        if (FMultiSelect) then
            s := s + ' MULTIPLE';
        s := s + '>';
        Add(s);
        for i := 0 to (FItems.Count - 1) do begin
            s := '<OPTION ';
            if (FItemIndex = i) then
                s := s + 'SELECTED ';
            if (Pos('=', FItems[i]) > 0) then begin
                s := s + 'VALUE="' + FItems.Names[i] + '">' + EscapeHTMLString(FItems.Values[FItems.Names[i]]);
            end else begin
                s := s + '>' + EscapeHTMLString(FItems[i]);
            end;
            Add(s + '</OPTION>');
        end; // for
        Add('</SELECT>');
    end; // with
end;

constructor THtmlSelect.Create(AOwner: TComponent);
begin
    inherited;
    ExposeProperties(['Size', 'Items', 'ItemIndex', 'MultiSelect']);
end;

{ translates between Html-style and WinAPI style RGB color. }
{ Both sides of the translation are identical - switch the }
{ leftmost and rightmost bytes }
function TranslateRGB(color: longint): longint;
var
    leftmost, rightmost: longint;
begin
    rightmost := color and $FF;
    leftmost := color and $FF0000;
    result := (rightmost shl 16) or (color and $00FF00) or (leftmost shr 16);
end;

function ColorToHtmlColor(Color: THtmlColor): string;
begin
    if ((Color = clDefault) or (Color = clNone)) then
        result := ''
    else
        result := '#' + IntToHex(TranslateRGB(ColorToRGB(Color)), 6);
end;

procedure TCustomHtmlText.SetText(const Value: string);
begin
    if (FText <> Value) then begin
        FText := Value;
        Change;
    end;
end;

procedure TCustomHtmlText.ProduceHtml(Dest: TStrings);
var
    s: string;
begin
    s := '<INPUT NAME="' + Name + '" TYPE="';
    if (FPassword) then
        s := s + 'PASSWORD'
    else
        s := s + 'TEXT';
    s := s + '"';
    if (FSize > 0) then
        s := s + ' SIZE="' + IntToStr(FSize) + '"';
    if (FMaxLength > 0) then
        s := s + ' MAXLENGTH="' + IntToStr(FMaxLength) + '"';
    s := s + ' VALUE="' + FText + '">';
    Dest.Add(s);
end;

procedure TCustomHtmlText.SubmitValue(const Value: string);
begin
    Text := Value;
end;

constructor THtmlText.Create(AOwner: TComponent);
begin
    inherited;
    ExposeProperties(['Text', 'MaxLength', 'Size', 'Password']);
end;

constructor TCustomHtmlTextArea.Create(AOwner: TComponent);
begin
    inherited;
    FLines := TStringList.Create;
    TStringList(FLines).OnChange := HandleLinesChange;
end;

destructor  TCustomHtmlTextArea.Destroy;
begin
    FLines.Free;
    inherited Destroy;
end;

procedure TCustomHtmlTextArea.HandleLinesChange(Sender: TObject);
begin
    Change;
end;

procedure TCustomHtmlTextArea.SetLines(Value: TStrings);
begin
    FLines.Assign(Value);
end;

procedure TCustomHtmlTextArea.ProduceHtml(Dest: TStrings);
var
    s: string;
    i: integer;
begin
    s := '<TEXTAREA NAME="' + Name + '"';
    if (FRows > 0) then
        s := s + ' ROWS="' + IntToStr(FRows) + '"';
    if (FCols > 0) then
        s := s + ' COLS="' + IntToStr(FCols) + '"';
    if (FMaxLength > 0) then
        s := s + ' MAXLENGTH="' + IntToStr(FMaxLength) + '"';
    s := s + '>';
    if (FLines.Count > 0) then
        s := s + EscapeHTMLString(FLines[0]);
    if (FLines.Count <= 1) then begin
        s := EscapeHTMLString(s) + '</TEXTAREA>';
        Dest.Add(s);
    end else begin
        Dest.Add(s);
        for i := 1 to (FLines.Count - 1) do
            if (i = FLines.Count - 1) then
                Dest.Add(EscapeHTMLString(FLines[i]) + '</TEXTAREA>')
            else
                Dest.Add(EscapeHTMLString(FLines[i]));
    end;
end;

procedure TCustomHtmlTextArea.SubmitValue(const Value: string);
begin
    Lines.Text := Value;
end;

constructor THtmlTextArea.Create(AOwner: TComponent);
begin
    inherited;
    ExposeProperties(['MaxLength', 'Rows', 'Cols']);
end;

constructor TCustomHtmlRadio.Create(AOwner: TComponent);
begin
    inherited;
    FValue := 'ON';
end;

procedure TCustomHtmlRadio.SetChecked(Value: boolean);
begin
    if (Value <> FChecked) then begin
        FChecked := Value;
        Change;
    end;
end;

procedure TCustomHtmlRadio.ProduceHtml(Dest: TStrings);
var
    s: string;
begin
    s := '<INPUT NAME="' + Name + '" TYPE="RADIO"';
    if (FValue <> '') then
        s := s + ' VALUE="' + FValue + '"';
    if (FChecked = true) then
        s := s + ' CHECKED';
    s := s + '>' + FCaption;
    Dest.Add(s);
end;

procedure TCustomHtmlRadio.SubmitValue(const Value: string);
begin
    Checked := (FValue = Value);
end;

constructor THtmlRadio.Create(AOwner: TComponent);
begin
    inherited;
    ExposeProperties(['Checked', 'Value']);
end;


constructor TCustomHtmlCheckbox.Create(AOwner: TComponent);
begin
    inherited;
    FValue := 'ON';
end;

procedure TCustomHtmlCheckbox.SetChecked(Value: boolean);
begin
    if (Value <> FChecked) then begin
        FChecked := Value;
        Change;
    end;
end;

procedure TCustomHtmlCheckbox.ProduceHtml(Dest: TStrings);
var
    s: string;
begin
    s := '<INPUT NAME="' + Name + '" TYPE="CHECKBOX"';
    if (FValue <> '') then
        s := s + ' VALUE="' + FValue + '"';
    if (FChecked = true) then
        s := s + ' CHECKED';
    s := s + '>' + FCaption;
    Dest.Add(s);
end;

procedure TCustomHtmlCheckbox.SubmitValue(const Value: string);
begin
    Checked := (FValue = Value);
end;

constructor THtmlCheckbox.Create(AOwner: TComponent);
begin
    inherited;
    ExposeProperties(['Checked', 'Value']);
end;

constructor TCustomHtmlButton.Create(AOwner: TComponent);
begin
    inherited;
    FButtonType := btSubmit;
end;

procedure TCustomHtmlButton.ProduceHtml(Dest: TStrings);
var
    s: string;
begin
    s := '<INPUT NAME="' + Name + '" TYPE="';
    case FButtonType of
        btNormal: s := s + 'BUTTON';
        btSubmit: s := s + 'SUBMIT';
        btReset: s := s + 'RESET';
    end;
    s := s + '"';
    if (FValue <> '') then
        s := s + ' VALUE="' + FValue + '"';
    s := s + '>';
    Dest.Add(s);
end;

procedure TCustomHtmlButton.SubmitValue(const Value: string);
begin
    // nothing to do
end;

procedure TCustomHtmlButton.SetValue(const Value: string);
begin
    if (Value <> FValue) then begin
        FValue := Value;
        Change;
    end;
end;


constructor THtmlButton.Create(AOwner: TComponent);
begin
    inherited;
    ExposeProperties(['Value', 'ButtonType']);
end;

constructor TCustomHtmlRadioGroup.Create(AOwner: TComponent);
begin
    inherited;
    FItems := TStringList.Create;
    TStringList(FItems).OnChange := OnItemsChange;
    FBetweenItems := '<BR>';
end;

destructor  TCustomHtmlRadioGroup.Destroy;
begin
    FItems.Free;
    inherited;
end;

procedure TCustomHtmlRadioGroup.SetItemIndex(Value: integer);
begin
    if (Value <> FItemIndex) then begin
        FItemIndex := Value;
        Change;
    end;
end;

procedure TCustomHtmlRadioGroup.OnItemsChange(Sender: TObject);
begin
    Change;
end;

procedure TCustomHtmlRadioGroup.SetItems(Value: TStrings);
begin
    FItems.Assign(Value);
end;

procedure TCustomHtmlRadioGroup.ProduceHtml(Dest: TStrings);
var
    s: string;
    i: integer;
begin
    for i := 0 to (FItems.Count - 1) do begin
        s := '<INPUT NAME="' + Name + '" TYPE="RADIO"';
        if (i = FItemIndex) then
            s := s + ' CHECKED';
        if (Pos('=', FItems[i]) > 0) then begin
            s := s + ' VALUE="' + FItems.Names[i] + '">' + FItems.Values[FItems.Names[i]];
        end else begin
            s := s + ' VALUE="' + FItems[i] + '">' + FItems[i];
        end;
        if (i < FItems.Count - 1) then
            s := s + FBetweenItems;
        Dest.Add(s);
    end;
end;

function TCustomHtmlRadioGroup.GetValueAt(Index: integer): string;
begin
    if (Pos('=', FItems[Index]) > 0) then
        result := FItems.Names[Index]
    else
        result := FItems[Index];
end;

function TCustomHtmlRadioGroup.FindValueIndex(const Value: string): integer;
begin
    for result := 0 to (FItems.Count - 1) do begin
        if (Trim(GetValueAt(result)) = Trim(Value)) then
            exit;
    end;
    result := -1;
end;

procedure TCustomHtmlRadioGroup.SubmitValue(const Value: string);
begin
    ItemIndex := FindValueIndex(Value);
end;

constructor THtmlRadioGroup.Create(AOwner: TComponent);
begin
    inherited;
    ExposeProperties(['BetweenItems', 'ItemIndex']);
end;


type
THtmlSelectStringList = class(TStringList)
private
    FBooleans: TList;
    function GetBoolean(Index: integer): boolean;
    procedure SetBoolean(Index: integer; Value: boolean);
    procedure UpdateBooleansCount;
public
    constructor Create;
    destructor Destroy; override;
    procedure Clear; override;
    procedure Delete(Index: Integer); override;
    procedure Exchange(Index1, Index2: Integer); override;
    procedure Assign(Source: TPersistent); override;
    property Booleans[Index: integer]: boolean read GetBoolean write SetBoolean;
end;

constructor THtmlSelectStringList.Create;
begin
    inherited;
    FBooleans := TList.Create;
end;

destructor THtmlSelectStringList.Destroy;
begin
    FBooleans.Free;
    inherited;
end;

procedure THtmlSelectStringList.UpdateBooleansCount;
begin
    FBooleans.Count := Count;
end;

procedure THtmlSelectStringList.Clear;
begin
    inherited;
    FBooleans.Clear;
end;

procedure THtmlSelectStringList.Delete(Index: Integer);
begin
    inherited;
    UpdateBooleansCount;
    FBooleans.Delete(Index);
end;

procedure THtmlSelectStringList.Exchange(Index1, Index2: Integer);
begin
    inherited;
    UpdateBooleansCount;
    FBooleans.Exchange(Index1, Index2);
end;

procedure THtmlSelectStringList.Assign(Source: TPersistent);
var
    i: integer;
begin
    BeginUpdate;
    try
        inherited;
        if (Source is THtmlSelectStringList) then begin
            FBooleans.Clear;
            for i := 0 to (THtmlSelectStringList(Source).Count - 1) do begin
                FBooleans.Add(THtmlSelectStringList(Source).FBooleans[i]);
            end;
        end;
    finally
        EndUpdate;
    end;
end;

function THtmlSelectStringList.GetBoolean(Index: integer): boolean;
begin
    UpdateBooleansCount;
    result := LongBool(FBooleans[Index]);
end;

procedure THtmlSelectStringList.SetBoolean(Index: integer; Value: boolean);
begin
    UpdateBooleansCount;
    FBooleans[Index] := pointer(ord(value));
end;

constructor TCustomHtmlCheckboxGroup.Create(AOwner: TComponent);
begin
    inherited;
    FItems := THtmlSelectStringList.Create;
    FBetweenItems := '<BR>';
end;

destructor  TCustomHtmlCheckboxGroup.Destroy;
begin
    FItems.Free;
    inherited;
end;

function TCustomHtmlCheckboxGroup.GetSelected(Index: integer): boolean;
begin
    result := THtmlSelectStringList(FItems).Booleans[Index];
end;

procedure TCustomHtmlCheckboxGroup.SetSelected(Index: integer; Value: boolean);
begin
    THtmlSelectStringList(FItems).Booleans[Index] := Value;
end;

procedure TCustomHtmlCheckboxGroup.SetItems(Value: TStrings);
begin
    FItems.Assign(Value);
end;

procedure TCustomHtmlCheckboxGroup.ProduceHtml(Dest: TStrings);
var
    s: string;
    i: integer;
begin
    for i := 0 to (FItems.Count - 1) do begin
        s := '<INPUT NAME="' + Name + '" TYPE="CHECKBOX"';
        if Selected[i] then
            s := s + ' CHECKED';
        if (Pos('=', FItems[i]) > 0) then begin
            s := s + ' VALUE="' + FItems.Names[i] + '">' + FItems.Values[FItems.Names[i]];
        end else begin
            s := s + ' VALUE="' + FItems[i] + '">' + FItems[i];
        end;
        if (i < FItems.Count - 1) then
            s := s + FBetweenItems;
        Dest.Add(s);
    end;
end;

function TCustomHtmlCheckboxGroup.GetValueAt(Index: integer): string;
begin
    if (Pos('=', FItems[Index]) > 0) then
        result := FItems.Names[Index]
    else
        result := FItems[Index];
end;

procedure TCustomHtmlCheckboxGroup.SubmitValue(const Value: string);
var
    i: integer;
    SubmittedValue: TStringList;
begin
    SubmittedValue := TStringList.Create;
    try
        SubmittedValue.Text := Value;
        for i := 0 to (FItems.Count - 1) do
            Selected[i] := (SubmittedValue.IndexOf(GetValueAt(i)) <> -1);
    finally
        SubmittedValue.Free;
    end;
end;

constructor THtmlCheckboxGroup.Create(AOwner: TComponent);
begin
    inherited;
    ExposeProperties(['BetweenItems']);
end;

procedure TCustomHtmlHidden.ProduceHtml(Dest: TStrings);
begin
    Dest.Add('<INPUT NAME="' + Name + '" TYPE="HIDDEN" VALUE="' + FValue + '">');
end;

procedure TCustomHtmlHidden.SetValue(const Value: string);
begin
    if (FValue <> Value) then begin
        FValue := Value;
    end;
end;

procedure TCustomHtmlHidden.SubmitValue(const Value: string);
begin
    Self.Value := Value;
end;

constructor THtmlHidden.Create(AOwner: TComponent);
begin
    inherited;
    ExposeProperties(['Value']);
end;

procedure THtmlFormControl.DoDefault(
    Request: THttpRequest; Response: THttpResponse;
    const Value: string; Params: TVariantList;
    var Handled: Boolean);
begin
    // The default verb for form controls is Submit
    ExecuteSubmit(Request, Response, Value, Params, Handled);
end;

procedure THtmlFormControl.Change;
begin
    if assigned(FOnChange) then
        FOnChange(Self);
end;

procedure THtmlFormControl.SetHtmlForm(Value: TCustomHtmlForm);
begin
    if (Value <> FHtmlForm) then begin
        if (FHtmlForm <> nil) then
            FHtmlForm.RemoveControl(Self);
        FHtmlForm := Value;
        if (FHtmlForm <> nil) then
            FHtmlForm.AddControl(Self);
    end;
end;

////////////////////////////////////////////////////////////////////////////////
//
// TCustomHtmlForm
//
////////////////////////////////////////////////////////////////////////////////

constructor TCustomHtmlForm.Create(AOwner: TComponent);
begin
    inherited;
    FControls := TList.Create;
end;

destructor TCustomHtmlForm.Destroy;
var
    i: integer;
begin
    for i := (ControlCount - 1) downto 0 do
        Controls[i].HtmlForm := nil;
    FControls.Free;
    inherited;
end;

procedure TCustomHtmlForm.AddControl(Control: THtmlFormControl);
begin
    if (FControls.IndexOf(Control) = -1) then
        FControls.Add(Control);
end;

procedure TCustomHtmlForm.RemoveControl(Control: THtmlFormControl);
var
    i: integer;
begin
    i := FControls.IndexOf(Control);
    if (i <> -1) then
        FControls.Delete(i);
end;

procedure TCustomHtmlForm.Execute(
    Request: THttpRequest; Response: THttpResponse;
    const Verb, Value: string; Params: TVariantList;
    var Handled: boolean);
begin
    if (CompareText(Verb, 'WriteFormBegin') = 0) then
        ExecuteWriteFormBegin(Request, Response, Value, Params, Handled)
    else if (CompareText(Verb, 'WriteFormEnd') = 0) then
        ExecuteWriteFormEnd(Request, Response, Value, Params, Handled)
    else if (CompareText(Verb, 'Submit') = 0) then
        ExecuteSubmit(Request, Response, Value, Params, Handled)
    else if (CompareText(Verb, 'WriteControlHtml') = 0) then
        ExecuteWriteControlHtml(Request, Response, Value, Params, Handled)
    else
        UnsupportedVerbError(Verb);
end;


procedure TCustomHtmlForm.ExecuteWriteFormBegin(
    Request: THttpRequest; Response: THttpResponse;
    const Value: string; Params: TVariantList;
    var Handled: boolean);
var
    Method: string;
    Action: string;
    EncType: string;
    Target: string;
begin
    Method := Params['Method'];
    if (Method = '') then
        Method := 'POST';
    Action := Params['Action'];
    if (Action = '') then
        Action := Request.ScriptName + '/' + Request.LogicalPath;
    EncType := Params['EncType'];
    Target := Params['Target'];
    Writeln(Response.TextOut, FormBegin(Name, Method, Action, EncType, Target));
    Writeln(Response.TextOut, '<INPUT NAME="' + Name + '.Submit" TYPE="HIDDEN">');
end;


procedure TCustomHtmlForm.ExecuteWriteFormEnd(
    Request: THttpRequest; Response: THttpResponse;
    const Value: string; Params: TVariantList;
    var Handled: boolean);
begin
    Writeln(Response.TextOut, '</FORM>');
end;

procedure TCustomHtmlForm.ExecuteSubmit(
    Request: THttpRequest; Response: THttpResponse;
    const Value: string; Params: TVariantList;
    var Handled: boolean);
var
    i: integer;
    ControlVerb, ControlValue: string;
    ControlParams: TVariantList;
    ControlHandled: boolean;
begin
    BeforeSubmit(Request, Response, Value, Params);
    try
        ControlParams := TVariantList.Create;
        try
            for i := 0 to (ControlCount - 1) do begin
                ControlParams.Clear;
                ExtractActionParams(Request, Controls[i].Name, ControlVerb, ControlValue, ControlParams);
                Controls[i].ExecuteSubmit(Request, Response, ControlValue, ControlParams, ControlHandled);
            end;
        finally
            ControlParams.Free;
        end;
    finally
        AfterSubmit(Request, Response, Value, Params);
    end;
end;

procedure TCustomHtmlForm.BeforeSubmit(
    Request: THttpRequest; Response: THttpResponse;
    const Value: string; Params: TVariantList);
begin
    if assigned(FOnBeforeSubmit) then
        FOnBeforeSubmit(Self, Request, Response, Value, Params);
end;

procedure TCustomHtmlForm.AfterSubmit(
    Request: THttpRequest; Response: THttpResponse;
    const Value: string; Params: TVariantList);
begin
    if assigned(FOnAfterSubmit) then
        FOnAfterSubmit(Self, Request, Response, Value, Params);
end;

function TCustomHtmlForm.GetControlCount: integer;
begin
    result := FControls.Count;
end;

function TCustomHtmlForm.GetControl(Index: integer): THtmlFormControl;
begin
    result := THtmlFormControl(FControls[Index]);
end;

procedure TCustomHtmlForm.ExecuteWriteControlHtml(
    Request: THttpRequest; Response: THttpResponse;
    const Value: string; Params: TVariantList;
    var Handled: boolean);
var
    ControlName: string;
    Control: THtmlFormControl;
    ControlParams: TVariantList;
begin
    ControlName := Params['Control'];
    if (ControlName = '') then
        raise Exception.Create('Control must be specified');
    Control := ControlByName(ControlName);
    if (Control = nil) then
        raise Exception.Create('Control "' + ControlName + '" not found');
    ControlParams := TVariantList.Create;
    try
        Control.ExecuteWriteHtml(Request, Response, '', ControlParams, Handled);
    finally
        ControlParams.Free;
    end;
end;

function TCustomHtmlForm.ControlByName(const Name: string): THtmlFormControl;
var
    i: integer;
begin
    for i := 0 to (ControlCount - 1) do begin
        result := Controls[i];
        if (CompareText(result.Name, Name) = 0) then
            exit;
    end;
    result := nil;
end;

// <Request.ScriptName>[LogicalPath][?QueryString]
function SelfURL(Request: THttpRequest; const LogicalPath: string; const QueryString: string): string;
begin
    result := Request.ScriptName;
    if (LogicalPath <> '') then
        result := result + LogicalPath;
    if (QueryString <> '') then
        result := result + '?' + QueryString;
end;

// Field1&Field2&Field3
function URLFields(const Fields: array of string): string;
var
    i: integer;
begin
    for i := Low(Fields) to High(Fields) do begin
        if (i <> Low(Fields)) then
            result := result + '&';
        result := result + Fields[i];
    end; // for
end;

// Field=URLEncode(Value)
function URLField(const Field, Value: string): string;
begin
    result := Field;
    if (Value <> '') then
        result := result + '=' + URLEncode(Value);
end;

function Action(const ActionName, Verb, Value: string): string;
begin
    result := ActionName;
    if (Verb <> '') then
        result := result + '.' + Verb;
    if (Value <> '') then
        result := result + '=' + Value;
end;

function ActionWithParams(const ActionName, Verb, Value: string; const Params: array of string): string;
var
    i: integer;
begin
    result := Action(ActionName, Verb, Value);
    for i := Low(Params) to High(Params) do 
        result := result + '&' + ActionName + '@' + Params[i];
end;

function ActionParam(const Param, Value: string): string;
begin
    result := Param;
    if (Value <> '') then
        result := result + '=' + URLEncode(Value);
end;


constructor TCustomHtmlChunk.Create(AOwner: TComponent);
begin
    inherited;
    FLines := TStringList.Create;
    FEscape := true;
end;

destructor TCustomHtmlChunk.Destroy;
begin
    FLines.Free;
    inherited Destroy;
end;

procedure TCustomHtmlChunk.SetLines(Value: TStrings);
begin
    FLines.Assign(Value);
end;

procedure TCustomHtmlChunk.ProduceHtml(Dest: TStrings);
begin
    Dest.Assign(FLines);
    if (FEscape) then
        EscapeHTMLStrings(Dest);
end;

procedure TCustomHtmlChunk.Change;
begin
    if assigned(FOnChange) then
        FOnChange(Self);
end;

function ColorToJSColor(Color: TColor): string;
var
    leftmost, middle, rightmost: longint;
begin
    if ((Color = clDefault) or (Color = clNone)) then
        result := ''
    else begin
        rightmost := Color and $FF;
        middle := (Color and $00FF00) shr 8;
        leftmost := (Color and $FF0000) shr 16;
        result := Format('rgb(%d, %d, %d)', [rightmost, middle, leftmost]);
    end;
end;

constructor TCustomHtmlJavaApplet.Create(AOwner: TComponent);
begin
    inherited;
    FParams := TStringList.Create;
end;

destructor  TCustomHtmlJavaApplet.Destroy;
begin
    FParams.Free;
    inherited;
end;

procedure TCustomHtmlJavaApplet.SetParams(Value: TStrings);
begin
    FParams.Assign(Value);
end;

procedure TCustomHtmlJavaApplet.ProduceHtml(Dest: TStrings);
var
    FormattedParams: TStringList;
begin
    with Dest do begin
        Add('<APPLET');
        if (FArchive <> '') then
            Add('  ARCHIVE="' + FArchive + '"');
        if (FCodeBase <> '') then
            Add('  CODEBASE="' + FCodeBase + '"');
        Add('  CODE="' + CODE + '"');
        Add('  NAME="' + Name + '"');
        Add('  WIDTH=' + IntToStr(FWidth));
        Add('  HEIGHT=' + IntToStr(FHeight));
        Add('  VSPACE=' + IntToStr(FVSpace));
        Add('  HSPACE=' + IntToStr(FHSpace));
        Add('  ALIGN=' + FAlign);
        Add('>');
        FormattedParams := TStringList.Create;
        try
            FormatStringsAsParams(FParams, FormattedParams);
            AddStrings(FormattedParams);
        finally
            FormattedParams.Free;
        end;
        Add('</APPLET>');
    end;
end;

procedure FormatStringsAsParams(SourceStrings: TStrings; DestParams: TStrings);
var
    i: integer;
    ParamName: string;
    ParamValue: string;
begin
    DestParams.BeginUpdate;
    try
        DestParams.Clear;
        for i := 0 to (SourceStrings.Count - 1) do begin
            StringToNameAndValue(SourceStrings[i], ParamName, ParamValue);
            DestParams.Add('<PARAM NAME="' + ParamName + '" VALUE="' + ParamValue + '">');
        end;
    finally
        DestParams.EndUpdate;
    end;
end;

end.
